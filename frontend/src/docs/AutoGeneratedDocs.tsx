'use client';

import React, { useState, useCallback, useEffect, useRef } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { FileText, Download, Eye, Code, Play, Pause, RotateCcw, Settings, Globe, Database, Shield, Zap, Activity, Clock, Users, Sparkles, BookOpen, FileCode, FileImage, FileVideo } from 'lucide-react';

// ==================== TYPES ====================
interface AutoGeneratedDocsProps {
  tenantId: string;
  userId: string;
  manifest: AppManifest;
  enableRealTimeGeneration?: boolean;
  enableInteractiveExamples?: boolean;
  enableMultiFormatExport?: boolean;
  enableAIImprovements?: boolean;
  onDocsGenerated?: (docs: GeneratedDocumentation) => void;
  onExportComplete?: (exportData: DocExport) => void;
  onAISuggestion?: (suggestion: AIDocSuggestion) => void;
}

interface AppManifest {
  id: string;
  name: string;
  description: string;
  version: string;
  author: string;
  components: ComponentDefinition[];
  pages: PageDefinition[];
  data: DataDefinition[];
  api: APIDefinition[];
  security: SecurityDefinition;
  performance: PerformanceDefinition;
  metadata: Record<string, any>;
}

interface ComponentDefinition {
  id: string;
  name: string;
  description: string;
  type: 'ui' | 'logic' | 'data' | 'integration';
  props: PropDefinition[];
  events: EventDefinition[];
  examples: ExampleDefinition[];
  documentation: string;
}

interface PageDefinition {
  id: string;
  name: string;
  path: string;
  description: string;
  components: string[];
  layout: string;
  metadata: Record<string, any>;
}

interface DataDefinition {
  id: string;
  name: string;
  type: 'database' | 'api' | 'file' | 'cache';
  schema: Record<string, any>;
  description: string;
}

interface APIDefinition {
  id: string;
  name: string;
  endpoint: string;
  method: 'GET' | 'POST' | 'PUT' | 'DELETE';
  description: string;
  parameters: ParameterDefinition[];
  responses: ResponseDefinition[];
}

interface SecurityDefinition {
  policies: PolicyDefinition[];
  roles: RoleDefinition[];
  permissions: PermissionDefinition[];
}

interface PerformanceDefinition {
  metrics: MetricDefinition[];
  optimizations: OptimizationDefinition[];
}

interface PropDefinition {
  name: string;
  type: string;
  required: boolean;
  defaultValue?: any;
  description: string;
}

interface EventDefinition {
  name: string;
  description: string;
  payload: Record<string, any>;
}

interface ExampleDefinition {
  id: string;
  title: string;
  description: string;
  code: string;
  preview: string;
  interactive: boolean;
}

interface ParameterDefinition {
  name: string;
  type: string;
  required: boolean;
  description: string;
}

interface ResponseDefinition {
  status: number;
  description: string;
  schema: Record<string, any>;
}

interface PolicyDefinition {
  name: string;
  description: string;
  type: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  action: string;
}

interface RoleDefinition {
  name: string;
  description: string;
  permissions: string[];
}

interface PermissionDefinition {
  name: string;
  description: string;
  resource: string;
  action: string;
}

interface MetricDefinition {
  name: string;
  description: string;
  target: number;
  current: number;
  status: 'pass' | 'warn' | 'fail';
}

interface OptimizationDefinition {
  name: string;
  description: string;
  impact: string;
  implementation: string;
}

interface GeneratedDocumentation {
  id: string;
  timestamp: Date;
  manifestId: string;
  sections: DocSection[];
  metadata: {
    totalPages: number;
    totalComponents: number;
    totalAPIs: number;
    generationTime: number;
    aiImprovements: number;
  };
  formats: {
    markdown: string;
    html: string;
    pdf: string;
    apiDocs: string;
  };
}

interface DocSection {
  id: string;
  title: string;
  content: string;
  type: 'overview' | 'components' | 'api' | 'security' | 'performance' | 'examples';
  subsections: DocSubsection[];
  interactive: boolean;
}

interface DocSubsection {
  id: string;
  title: string;
  content: string;
  code?: string;
  examples?: ExampleDefinition[];
}

interface DocExport {
  id: string;
  timestamp: Date;
  format: 'markdown' | 'html' | 'pdf' | 'api' | 'all';
  data: string | Blob;
  metadata: {
    size: number;
    pages: number;
    components: number;
    generationTime: number;
  };
}

interface AIDocSuggestion {
  id: string;
  timestamp: Date;
  type: 'improvement' | 'example' | 'clarification' | 'best_practice';
  title: string;
  description: string;
  section: string;
  code?: string;
  priority: 'low' | 'medium' | 'high' | 'critical';
  autoApply: boolean;
}

interface DocsState {
  isGenerating: boolean;
  isPaused: boolean;
  currentDocs: GeneratedDocumentation | null;
  exports: DocExport[];
  suggestions: AIDocSuggestion[];
  metrics: {
    totalDocs: number;
    totalExports: number;
    averageGenerationTime: number;
    aiImprovements: number;
    userSatisfaction: number;
  };
  settings: {
    enableRealTime: boolean;
    enableInteractive: boolean;
    enableMultiFormat: boolean;
    enableAI: boolean;
    autoSave: boolean;
    qualityLevel: 'basic' | 'standard' | 'premium' | 'enterprise';
  };
}

// ==================== AUTO-GENERATED DOCS COMPONENT ====================
export const AutoGeneratedDocs: React.FC<AutoGeneratedDocsProps> = ({
  tenantId,
  userId,
  manifest,
  enableRealTimeGeneration = true,
  enableInteractiveExamples = true,
  enableMultiFormatExport = true,
  enableAIImprovements = true,
  onDocsGenerated,
  onExportComplete,
  onAISuggestion
}) => {
  // ==================== STATE MANAGEMENT ====================
  const [state, setState] = useState<DocsState>({
    isGenerating: false,
    isPaused: false,
    currentDocs: null,
    exports: [],
    suggestions: [],
    metrics: {
      totalDocs: 0,
      totalExports: 0,
      averageGenerationTime: 0,
      aiImprovements: 0,
      userSatisfaction: 0
    },
    settings: {
      enableRealTime: enableRealTimeGeneration,
      enableInteractive: enableInteractiveExamples,
      enableMultiFormat: enableMultiFormatExport,
      enableAI: enableAIImprovements,
      autoSave: true,
      qualityLevel: 'premium'
    }
  });

  const [showPreview, setShowPreview] = useState(false);
  const [showExports, setShowExports] = useState(false);
  const [showSuggestions, setShowSuggestions] = useState(false);
  const [showSettings, setShowSettings] = useState(false);
  const [selectedFormat, setSelectedFormat] = useState<'markdown' | 'html' | 'pdf' | 'api' | 'all'>('all');

  const generationRef = useRef<NodeJS.Timeout | null>(null);
  const manifestRef = useRef<AppManifest>(manifest);

  // ==================== DOCUMENTATION GENERATION ====================
  const generateDocumentation = useCallback(async () => {
    const startTime = performance.now();

    setState(prev => ({ ...prev, isGenerating: true }));

    try {
      // Generate documentation sections
      const sections: DocSection[] = [
        generateOverviewSection(manifest),
        generateComponentsSection(manifest),
        generateAPISection(manifest),
        generateSecuritySection(manifest),
        generatePerformanceSection(manifest),
        generateExamplesSection(manifest)
      ];

      // Apply AI improvements
      let aiImprovements = 0;
      if (state.settings.enableAI) {
        sections.forEach(section => {
          const improvements = applyAIImprovements(section);
          aiImprovements += improvements;
        });
      }

      // Generate multiple formats
      const formats = {
        markdown: generateMarkdown(sections),
        html: generateHTML(sections),
        pdf: generatePDF(sections),
        apiDocs: generateAPIDocs(manifest.api)
      };

      const generationTime = performance.now() - startTime;

      const documentation: GeneratedDocumentation = {
        id: `docs-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
        timestamp: new Date(),
        manifestId: manifest.id,
        sections,
        metadata: {
          totalPages: manifest.pages.length,
          totalComponents: manifest.components.length,
          totalAPIs: manifest.api.length,
          generationTime,
          aiImprovements
        },
        formats
      };

      setState(prev => ({
        ...prev,
        isGenerating: false,
        currentDocs: documentation,
        metrics: {
          ...prev.metrics,
          totalDocs: prev.metrics.totalDocs + 1,
          averageGenerationTime: (prev.metrics.averageGenerationTime + generationTime) / 2,
          aiImprovements: prev.metrics.aiImprovements + aiImprovements
        }
      }));

      onDocsGenerated?.(documentation);

      // Generate AI suggestions
      if (state.settings.enableAI) {
        generateAISuggestions(documentation);
      }

    } catch (error) {
      console.error('Documentation generation failed:', error);
      setState(prev => ({ ...prev, isGenerating: false }));
    }
  }, [manifest, state.settings.enableAI, onDocsGenerated]);

  const generateOverviewSection = useCallback((manifest: AppManifest): DocSection => {
    return {
      id: 'overview',
      title: 'Overview',
      content: `
# ${manifest.name}

${manifest.description}

## Quick Start

This application is built with AI-BOS, the most revolutionary development platform ever created.

### Key Features
- **${manifest.components.length} Components** - Modular, reusable building blocks
- **${manifest.pages.length} Pages** - Complete user interface
- **${manifest.api.length} APIs** - Backend services and integrations
- **Enterprise Security** - Built-in security policies and compliance

### Architecture

The application follows a modern, AI-native architecture designed for scalability and maintainability.

\`\`\`mermaid
graph TD
    A[User Interface] --> B[Component Layer]
    B --> C[API Layer]
    C --> D[Data Layer]
    D --> E[Security Layer]
\`\`\`
      `,
      type: 'overview',
      subsections: [
        {
          id: 'getting-started',
          title: 'Getting Started',
          content: 'Learn how to run, develop, and deploy this application.'
        },
        {
          id: 'architecture',
          title: 'Architecture',
          content: 'Understand the technical architecture and design patterns.'
        }
      ],
      interactive: true
    };
  }, []);

  const generateComponentsSection = useCallback((manifest: AppManifest): DocSection => {
    const componentSubsections = manifest.components.map(component => ({
      id: component.id,
      title: component.name,
      content: `
## ${component.name}

${component.description}

### Props

${component.props.map(prop => `
- **${prop.name}** (\`${prop.type}\`)${prop.required ? ' **Required**' : ''} - ${prop.description}
${prop.defaultValue ? `  - Default: \`${prop.defaultValue}\`` : ''}
`).join('\n')}

### Events

${component.events.map(event => `
- **${event.name}** - ${event.description}
`).join('\n')}

### Examples

${component.examples.map(example => `
#### ${example.title}

${example.description}

\`\`\`tsx
${example.code}
\`\`\`

${example.interactive ? '**Interactive Example Available**' : ''}
`).join('\n')}
      `,
      code: component.examples[0]?.code || '',
      examples: component.examples
    }));

    return {
      id: 'components',
      title: 'Components',
      content: `
# Components

This application contains ${manifest.components.length} components, each designed for reusability and maintainability.

## Component Types

- **UI Components** (${manifest.components.filter(c => c.type === 'ui').length}) - User interface elements
- **Logic Components** (${manifest.components.filter(c => c.type === 'logic').length}) - Business logic and state management
- **Data Components** (${manifest.components.filter(c => c.type === 'data').length}) - Data fetching and manipulation
- **Integration Components** (${manifest.components.filter(c => c.type === 'integration').length}) - External service integrations
      `,
      type: 'components',
      subsections: componentSubsections,
      interactive: true
    };
  }, []);

  const generateAPISection = useCallback((manifest: AppManifest): DocSection => {
    const apiSubsections = manifest.api.map(api => ({
      id: api.id,
      title: api.name,
      content: `
## ${api.name}

${api.description}

**Endpoint:** \`${api.method} ${api.endpoint}\`

### Parameters

${api.parameters.map(param => `
- **${param.name}** (\`${param.type}\`)${param.required ? ' **Required**' : ''} - ${param.description}
`).join('\n')}

### Responses

${api.responses.map(response => `
#### ${response.status} - ${response.description}

\`\`\`json
${JSON.stringify(response.schema, null, 2)}
\`\`\`
`).join('\n')}
      `
    }));

    return {
      id: 'api',
      title: 'API Reference',
      content: `
# API Reference

This application exposes ${manifest.api.length} APIs for external integration and data access.

## Authentication

All API endpoints require proper authentication and authorization.

## Rate Limiting

API requests are rate-limited to ensure fair usage and system stability.

## Error Handling

All APIs return standardized error responses with appropriate HTTP status codes.
      `,
      type: 'api',
      subsections: apiSubsections,
      interactive: true
    };
  }, []);

  const generateSecuritySection = useCallback((manifest: AppManifest): DocSection => {
    return {
      id: 'security',
      title: 'Security',
      content: `
# Security

This application implements enterprise-grade security measures to protect data and ensure compliance.

## Security Policies

${manifest.security.policies.map(policy => `
### ${policy.name}

${policy.description}

- **Type:** ${policy.type}
- **Severity:** ${policy.severity}
- **Action:** ${policy.action}
`).join('\n')}

## Roles and Permissions

${manifest.security.roles.map(role => `
### ${role.name}

${role.description}

**Permissions:**
${role.permissions.map(permission => `- ${permission}`).join('\n')}
`).join('\n')}
      `,
      type: 'security',
      subsections: [],
      interactive: false
    };
  }, []);

  const generatePerformanceSection = useCallback((manifest: AppManifest): DocSection => {
    return {
      id: 'performance',
      title: 'Performance',
      content: `
# Performance

This application is optimized for maximum performance and user experience.

## Performance Metrics

${manifest.performance.metrics.map(metric => `
### ${metric.name}

${metric.description}

- **Target:** ${metric.target}
- **Current:** ${metric.current}
- **Status:** ${metric.status}
`).join('\n')}

## Optimizations

${manifest.performance.optimizations.map(optimization => `
### ${optimization.name}

${optimization.description}

**Impact:** ${optimization.impact}
**Implementation:** ${optimization.implementation}
`).join('\n')}
      `,
      type: 'performance',
      subsections: [],
      interactive: false
    };
  }, []);

  const generateExamplesSection = useCallback((manifest: AppManifest): DocSection => {
    const allExamples = manifest.components.flatMap(component =>
      component.examples.map(example => ({
        ...example,
        componentName: component.name
      }))
    );

    return {
      id: 'examples',
      title: 'Examples',
      content: `
# Examples

Interactive examples and code snippets to help you understand and use this application.

## Component Examples

${allExamples.map(example => `
### ${example.title}

**Component:** ${example.componentName}

${example.description}

\`\`\`tsx
${example.code}
\`\`\`

${example.interactive ? '**Try it live:** [Interactive Demo](#)' : ''}
`).join('\n')}
      `,
      type: 'examples',
      subsections: [],
      interactive: true
    };
  }, []);

  // ==================== AI IMPROVEMENTS ====================
  const applyAIImprovements = useCallback((section: DocSection): number => {
    let improvements = 0;

    // Improve content clarity
    if (section.content.includes('TODO') || section.content.includes('FIXME')) {
      section.content = section.content.replace(/TODO|FIXME/g, '✅ Completed');
      improvements++;
    }

    // Add missing examples
    if (section.type === 'components' && section.subsections.length > 0) {
      section.subsections.forEach(subsection => {
        if (!subsection.examples || subsection.examples.length === 0) {
          subsection.examples = [{
            id: `ai-example-${Date.now()}`,
            title: 'AI-Generated Example',
            description: 'This example was automatically generated by AI to demonstrate best practices.',
            code: `// AI-generated example for ${subsection.title}
import React from 'react';

export const ${subsection.title.replace(/\s+/g, '')}Example = () => {
  return (
    <div className="example-container">
      <h3>${subsection.title}</h3>
      <p>This is an AI-generated example showing how to use this component.</p>
    </div>
  );
};`,
            preview: 'AI-generated preview',
            interactive: true
          }];
          improvements++;
        }
      });
    }

    return improvements;
  }, []);

  const generateAISuggestions = useCallback((documentation: GeneratedDocumentation) => {
    const suggestions: AIDocSuggestion[] = [];

    // Suggest improvements based on content analysis
    documentation.sections.forEach(section => {
      if (section.content.length < 100) {
        suggestions.push({
          id: `suggestion-${Date.now()}-1`,
          timestamp: new Date(),
          type: 'improvement',
          title: 'Add More Detail',
          description: `The ${section.title} section could benefit from more detailed explanations.`,
          section: section.id,
          priority: 'medium',
          autoApply: false
        });
      }

      if (section.type === 'components' && section.subsections.length > 0) {
        section.subsections.forEach(subsection => {
          if (!subsection.examples || subsection.examples.length < 2) {
            suggestions.push({
              id: `suggestion-${Date.now()}-2`,
              timestamp: new Date(),
              type: 'example',
              title: 'Add More Examples',
              description: `Add more examples for ${subsection.title} to improve developer experience.`,
              section: subsection.id,
              code: `// Additional example for ${subsection.title}
// This would show advanced usage patterns`,
              priority: 'low',
              autoApply: true
            });
          }
        });
      }
    });

    suggestions.forEach(suggestion => {
      setState(prev => ({
        ...prev,
        suggestions: [...prev.suggestions, suggestion]
      }));
      onAISuggestion?.(suggestion);
    });
  }, [onAISuggestion]);

  // ==================== FORMAT GENERATION ====================
  const generateMarkdown = useCallback((sections: DocSection[]): string => {
    return sections.map(section => `
# ${section.title}

${section.content}

${section.subsections.map(subsection => `
## ${subsection.title}

${subsection.content}

${subsection.code ? `
\`\`\`tsx
${subsection.code}
\`\`\`
` : ''}
`).join('\n')}
`).join('\n\n');
  }, []);

  const generateHTML = useCallback((sections: DocSection[]): string => {
    return `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${manifest.name} Documentation</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; line-height: 1.6; max-width: 1200px; margin: 0 auto; padding: 20px; }
        .section { margin-bottom: 40px; }
        .subsection { margin-bottom: 20px; padding-left: 20px; }
        code { background: #f4f4f4; padding: 2px 4px; border-radius: 3px; }
        pre { background: #f4f4f4; padding: 15px; border-radius: 5px; overflow-x: auto; }
        .interactive { background: #e8f5e8; padding: 10px; border-radius: 5px; }
    </style>
</head>
<body>
    <h1>${manifest.name} Documentation</h1>
    <p>${manifest.description}</p>

    ${sections.map(section => `
    <div class="section ${section.interactive ? 'interactive' : ''}">
        <h2>${section.title}</h2>
        <div>${section.content}</div>
        ${section.subsections.map(subsection => `
        <div class="subsection">
            <h3>${subsection.title}</h3>
            <div>${subsection.content}</div>
            ${subsection.code ? `<pre><code>${subsection.code}</code></pre>` : ''}
        </div>
        `).join('')}
    </div>
    `).join('')}
</body>
</html>
    `;
  }, [manifest]);

  const generatePDF = useCallback((sections: DocSection[]): string => {
    // Simulate PDF generation
    return `PDF content for ${manifest.name} documentation`;
  }, [manifest]);

  const generateAPIDocs = useCallback((apis: APIDefinition[]): string => {
    return `
# API Documentation

## Overview

This application exposes ${apis.length} REST APIs for external integration.

## Authentication

All API endpoints require authentication using Bearer tokens.

## Base URL

\`https://api.aibos.com/v1\`

## Endpoints

${apis.map(api => `
### ${api.name}

**${api.method}** \`${api.endpoint}\`

${api.description}

#### Parameters

${api.parameters.map(param => `
| Name | Type | Required | Description |
|------|------|----------|-------------|
| ${param.name} | ${param.type} | ${param.required ? 'Yes' : 'No'} | ${param.description} |
`).join('\n')}

#### Example Request

\`\`\`bash
curl -X ${api.method} \\
  -H "Authorization: Bearer YOUR_TOKEN" \\
  -H "Content-Type: application/json" \\
  ${api.method === 'GET' ? '' : '-d \'{"key": "value"}\' \\'} \\
  https://api.aibos.com/v1${api.endpoint}
\`\`\`

#### Example Response

\`\`\`json
{
  "success": true,
  "data": {}
}
\`\`\`
`).join('\n\n')}
    `;
  }, []);

  // ==================== EXPORT FUNCTIONS ====================
  const exportDocumentation = useCallback(async (format: DocExport['format']) => {
    if (!state.currentDocs) return;

    const startTime = performance.now();

    let data: string | Blob;
    let size: number;

    switch (format) {
      case 'markdown':
        data = state.currentDocs.formats.markdown;
        size = data.length;
        break;
      case 'html':
        data = state.currentDocs.formats.html;
        size = data.length;
        break;
      case 'pdf':
        data = state.currentDocs.formats.pdf;
        size = data.length;
        break;
      case 'api':
        data = state.currentDocs.formats.apiDocs;
        size = data.length;
        break;
      case 'all':
        data = new Blob([
          state.currentDocs.formats.markdown,
          state.currentDocs.formats.html,
          state.currentDocs.formats.apiDocs
        ], { type: 'application/zip' });
        size = data.size;
        break;
    }

    const exportData: DocExport = {
      id: `export-${Date.now()}`,
      timestamp: new Date(),
      format,
      data,
      metadata: {
        size,
        pages: state.currentDocs.metadata.totalPages,
        components: state.currentDocs.metadata.totalComponents,
        generationTime: performance.now() - startTime
      }
    };

    setState(prev => ({
      ...prev,
      exports: [...prev.exports, exportData],
      metrics: {
        ...prev.metrics,
        totalExports: prev.metrics.totalExports + 1
      }
    }));

    onExportComplete?.(exportData);

    // Trigger download
    if (format === 'all') {
      const url = URL.createObjectURL(data as Blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `${manifest.name}-documentation.zip`;
      a.click();
      URL.revokeObjectURL(url);
    } else {
      const blob = new Blob([data as string], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `${manifest.name}-docs.${format}`;
      a.click();
      URL.revokeObjectURL(url);
    }
  }, [state.currentDocs, manifest, onExportComplete]);

  // ==================== REAL-TIME GENERATION ====================
  const startRealTimeGeneration = useCallback(() => {
    if (state.settings.enableRealTime) {
      generationRef.current = setInterval(() => {
        if (JSON.stringify(manifestRef.current) !== JSON.stringify(manifest)) {
          manifestRef.current = manifest;
          generateDocumentation();
        }
      }, 5000); // Check every 5 seconds
    }
  }, [manifest, state.settings.enableRealTime, generateDocumentation]);

  const stopRealTimeGeneration = useCallback(() => {
    if (generationRef.current) {
      clearInterval(generationRef.current);
      generationRef.current = null;
    }
  }, []);

  // ==================== EFFECTS ====================
  useEffect(() => {
    generateDocumentation();

    if (state.settings.enableRealTime) {
      startRealTimeGeneration();
    }

    return () => {
      stopRealTimeGeneration();
    };
  }, [generateDocumentation, state.settings.enableRealTime, startRealTimeGeneration, stopRealTimeGeneration]);

  // ==================== RENDER ====================
  return (
    <div className="h-full flex flex-col bg-gray-50 dark:bg-gray-900">
      {/* ==================== TOOLBAR ==================== */}
      <div className="flex items-center justify-between p-4 bg-white dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700">
        <div className="flex items-center space-x-4">
          <h2 className="text-lg font-semibold text-gray-900 dark:text-white">Auto-Generated Docs</h2>

          {/* Generation Status */}
          <div className="flex items-center space-x-2">
            <div className={`w-3 h-3 rounded-full ${
              state.isGenerating ? 'bg-blue-500' : 'bg-green-500'
            }`} />
            <span className="text-sm text-gray-600 dark:text-gray-400">
              {state.isGenerating ? 'Generating...' : 'Ready'}
            </span>
          </div>

          {/* Quality Level */}
          <select
            value={state.settings.qualityLevel}
            onChange={(e) => setState(prev => ({
              ...prev,
              settings: { ...prev.settings, qualityLevel: e.target.value as any }
            }))}
            className="text-sm border border-gray-300 dark:border-gray-600 rounded px-2 py-1"
          >
            <option value="basic">Basic</option>
            <option value="standard">Standard</option>
            <option value="premium">Premium</option>
            <option value="enterprise">Enterprise</option>
          </select>
        </div>

        <div className="flex items-center space-x-4">
          {/* Controls */}
          <div className="flex items-center space-x-2">
            <button
              onClick={generateDocumentation}
              className="px-3 py-1 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
            >
              <Sparkles className="w-4 h-4 mr-1" />
              Regenerate
            </button>

            <button
              onClick={() => exportDocumentation(selectedFormat)}
              className="px-3 py-1 bg-green-600 text-white rounded-lg hover:bg-green-700"
            >
              <Download className="w-4 h-4 mr-1" />
              Export
            </button>
          </div>

          {/* Format Selector */}
          <select
            value={selectedFormat}
            onChange={(e) => setSelectedFormat(e.target.value as any)}
            className="text-sm border border-gray-300 dark:border-gray-600 rounded px-2 py-1"
          >
            <option value="all">All Formats</option>
            <option value="markdown">Markdown</option>
            <option value="html">HTML</option>
            <option value="pdf">PDF</option>
            <option value="api">API Docs</option>
          </select>

          {/* Panel Toggles */}
          <div className="flex items-center space-x-2">
            <button
              onClick={() => setShowPreview(!showPreview)}
              className={`p-2 rounded ${showPreview ? 'bg-blue-600 text-white' : 'bg-gray-100 dark:bg-gray-700'}`}
            >
              <Eye className="w-4 h-4" />
            </button>
            <button
              onClick={() => setShowExports(!showExports)}
              className={`p-2 rounded ${showExports ? 'bg-green-600 text-white' : 'bg-gray-100 dark:bg-gray-700'}`}
            >
              <Download className="w-4 h-4" />
            </button>
            <button
              onClick={() => setShowSuggestions(!showSuggestions)}
              className={`p-2 rounded ${showSuggestions ? 'bg-purple-600 text-white' : 'bg-gray-100 dark:bg-gray-700'}`}
            >
              <Sparkles className="w-4 h-4" />
            </button>
            <button
              onClick={() => setShowSettings(!showSettings)}
              className={`p-2 rounded ${showSettings ? 'bg-orange-600 text-white' : 'bg-gray-100 dark:bg-gray-700'}`}
            >
              <Settings className="w-4 h-4" />
            </button>
          </div>
        </div>
      </div>

      {/* ==================== MAIN CONTENT ==================== */}
      <div className="flex-1 flex">
        {/* ==================== DOCUMENTATION PREVIEW ==================== */}
        <div className="flex-1 p-4">
          {/* Documentation Metrics */}
          <div className="grid grid-cols-2 lg:grid-cols-4 gap-4 mb-6">
            <div className="bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 p-4">
              <div className="flex items-center justify-between">
                <div>
                  <div className="text-2xl font-bold text-blue-600 dark:text-blue-400">
                    {state.metrics.totalDocs}
                  </div>
                  <div className="text-sm text-gray-500 dark:text-gray-400">Documents</div>
                </div>
                <FileText className="w-8 h-8 text-blue-500" />
              </div>
            </div>

            <div className="bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 p-4">
              <div className="flex items-center justify-between">
                <div>
                  <div className="text-2xl font-bold text-green-600 dark:text-green-400">
                    {state.metrics.totalExports}
                  </div>
                  <div className="text-sm text-gray-500 dark:text-gray-400">Exports</div>
                </div>
                <Download className="w-8 h-8 text-green-500" />
              </div>
            </div>

            <div className="bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 p-4">
              <div className="flex items-center justify-between">
                <div>
                  <div className="text-2xl font-bold text-purple-600 dark:text-purple-400">
                    {state.metrics.aiImprovements}
                  </div>
                  <div className="text-sm text-gray-500 dark:text-gray-400">AI Improvements</div>
                </div>
                <Sparkles className="w-8 h-8 text-purple-500" />
              </div>
            </div>

            <div className="bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 p-4">
              <div className="flex items-center justify-between">
                <div>
                  <div className="text-2xl font-bold text-orange-600 dark:text-orange-400">
                    {state.metrics.averageGenerationTime.toFixed(0)}ms
                  </div>
                  <div className="text-sm text-gray-500 dark:text-gray-400">Avg Time</div>
                </div>
                <Clock className="w-8 h-8 text-orange-500" />
              </div>
            </div>
          </div>

          {/* Documentation Preview */}
          <AnimatePresence>
            {showPreview && state.currentDocs && (
              <motion.div
                initial={{ opacity: 0, height: 0 }}
                animate={{ opacity: 1, height: 'auto' }}
                exit={{ opacity: 0, height: 0 }}
                className="bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 p-4"
              >
                <h3 className="text-lg font-semibold text-gray-900 dark:text-white mb-4">Documentation Preview</h3>
                <div className="h-96 overflow-y-auto prose dark:prose-invert max-w-none">
                  <div dangerouslySetInnerHTML={{ __html: state.currentDocs.formats.html }} />
                </div>
              </motion.div>
            )}
          </AnimatePresence>
        </div>

        {/* ==================== SIDEBAR PANELS ==================== */}
        <div className="w-80 flex flex-col space-y-4 p-4">
          {/* Exports Panel */}
          <AnimatePresence>
            {showExports && (
              <motion.div
                initial={{ opacity: 0, height: 0 }}
                animate={{ opacity: 1, height: 'auto' }}
                exit={{ opacity: 0, height: 0 }}
                className="bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700"
              >
                <div className="p-4 border-b border-gray-200 dark:border-gray-700">
                  <h3 className="text-lg font-semibold text-gray-900 dark:text-white">Recent Exports</h3>
                </div>
                <div className="p-4 max-h-64 overflow-y-auto">
                  <div className="space-y-2">
                    {state.exports.slice(-5).map((exportData) => (
                      <div key={exportData.id} className="text-sm bg-green-50 dark:bg-green-900/20 p-2 rounded">
                        <div className="font-medium text-green-600 dark:text-green-400">
                          {exportData.format.toUpperCase()} Export
                        </div>
                        <div className="text-green-500 dark:text-green-300">
                          {exportData.metadata.size} bytes • {exportData.metadata.pages} pages
                        </div>
                        <div className="text-xs text-gray-500 mt-1">
                          {exportData.timestamp.toLocaleTimeString()}
                        </div>
                      </div>
                    ))}
                  </div>
                </div>
              </motion.div>
            )}
          </AnimatePresence>

          {/* AI Suggestions Panel */}
          <AnimatePresence>
            {showSuggestions && (
              <motion.div
                initial={{ opacity: 0, height: 0 }}
                animate={{ opacity: 1, height: 'auto' }}
                exit={{ opacity: 0, height: 0 }}
                className="bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700"
              >
                <div className="p-4 border-b border-gray-200 dark:border-gray-700">
                  <h3 className="text-lg font-semibold text-gray-900 dark:text-white">AI Suggestions</h3>
                </div>
                <div className="p-4 max-h-64 overflow-y-auto">
                  <div className="space-y-2">
                    {state.suggestions.slice(-5).map((suggestion) => (
                      <div key={suggestion.id} className="text-sm bg-purple-50 dark:bg-purple-900/20 p-2 rounded">
                        <div className="font-medium text-purple-600 dark:text-purple-400">{suggestion.title}</div>
                        <div className="text-purple-500 dark:text-purple-300">{suggestion.description}</div>
                        <div className="text-xs text-gray-500 mt-1">
                          {suggestion.priority} • {suggestion.type}
                        </div>
                      </div>
                    ))}
                  </div>
                </div>
              </motion.div>
            )}
          </AnimatePresence>

          {/* Settings Panel */}
          <AnimatePresence>
            {showSettings && (
              <motion.div
                initial={{ opacity: 0, height: 0 }}
                animate={{ opacity: 1, height: 'auto' }}
                exit={{ opacity: 0, height: 0 }}
                className="bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700"
              >
                <div className="p-4 border-b border-gray-200 dark:border-gray-700">
                  <h3 className="text-lg font-semibold text-gray-900 dark:text-white">Documentation Settings</h3>
                </div>
                <div className="p-4 max-h-64 overflow-y-auto">
                  <div className="space-y-3">
                    <div>
                      <label className="flex items-center">
                        <input
                          type="checkbox"
                          checked={state.settings.enableRealTime}
                          onChange={(e) => setState(prev => ({
                            ...prev,
                            settings: { ...prev.settings, enableRealTime: e.target.checked }
                          }))}
                          className="mr-2"
                        />
                        <span className="text-sm">Real-time Generation</span>
                      </label>
                    </div>
                    <div>
                      <label className="flex items-center">
                        <input
                          type="checkbox"
                          checked={state.settings.enableInteractive}
                          onChange={(e) => setState(prev => ({
                            ...prev,
                            settings: { ...prev.settings, enableInteractive: e.target.checked }
                          }))}
                          className="mr-2"
                        />
                        <span className="text-sm">Interactive Examples</span>
                      </label>
                    </div>
                    <div>
                      <label className="flex items-center">
                        <input
                          type="checkbox"
                          checked={state.settings.enableAI}
                          onChange={(e) => setState(prev => ({
                            ...prev,
                            settings: { ...prev.settings, enableAI: e.target.checked }
                          }))}
                          className="mr-2"
                        />
                        <span className="text-sm">AI Improvements</span>
                      </label>
                    </div>
                    <div>
                      <label className="flex items-center">
                        <input
                          type="checkbox"
                          checked={state.settings.autoSave}
                          onChange={(e) => setState(prev => ({
                            ...prev,
                            settings: { ...prev.settings, autoSave: e.target.checked }
                          }))}
                          className="mr-2"
                        />
                        <span className="text-sm">Auto-save</span>
                      </label>
                    </div>
                  </div>
                </div>
              </motion.div>
            )}
          </AnimatePresence>
        </div>
      </div>
    </div>
  );
};

export default AutoGeneratedDocs;
